{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport function compactDecrypt(_x, _x2, _x3) {\n  return _compactDecrypt.apply(this, arguments);\n}\n\nfunction _compactDecrypt() {\n  _compactDecrypt = _asyncToGenerator(function* (jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n      jwe = decoder.decode(jwe);\n    }\n\n    if (typeof jwe !== 'string') {\n      throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n\n    const {\n      0: protectedHeader,\n      1: encryptedKey,\n      2: iv,\n      3: ciphertext,\n      4: tag,\n      length\n    } = jwe.split('.');\n\n    if (length !== 5) {\n      throw new JWEInvalid('Invalid Compact JWE');\n    }\n\n    const decrypted = yield flattenedDecrypt({\n      ciphertext,\n      iv: iv || undefined,\n      protected: protectedHeader || undefined,\n      tag: tag || undefined,\n      encrypted_key: encryptedKey || undefined\n    }, key, options);\n    const result = {\n      plaintext: decrypted.plaintext,\n      protectedHeader: decrypted.protectedHeader\n    };\n\n    if (typeof key === 'function') {\n      return { ...result,\n        key: decrypted.key\n      };\n    }\n\n    return result;\n  });\n  return _compactDecrypt.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/jwe/compact/decrypt.js"],"names":["flattenedDecrypt","JWEInvalid","decoder","compactDecrypt","jwe","key","options","Uint8Array","decode","protectedHeader","encryptedKey","iv","ciphertext","tag","length","split","decrypted","undefined","protected","encrypted_key","result","plaintext"],"mappings":";AAAA,SAASA,gBAAT,QAAiC,yBAAjC;AACA,SAASC,UAAT,QAA2B,sBAA3B;AACA,SAASC,OAAT,QAAwB,2BAAxB;AACA,gBAAsBC,cAAtB;AAAA;AAAA;;;sCAAO,WAA8BC,GAA9B,EAAmCC,GAAnC,EAAwCC,OAAxC,EAAiD;AACpD,QAAIF,GAAG,YAAYG,UAAnB,EAA+B;AAC3BH,MAAAA,GAAG,GAAGF,OAAO,CAACM,MAAR,CAAeJ,GAAf,CAAN;AACH;;AACD,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzB,YAAM,IAAIH,UAAJ,CAAe,4CAAf,CAAN;AACH;;AACD,UAAM;AAAE,SAAGQ,eAAL;AAAsB,SAAGC,YAAzB;AAAuC,SAAGC,EAA1C;AAA8C,SAAGC,UAAjD;AAA6D,SAAGC,GAAhE;AAAqEC,MAAAA;AAArE,QAAiFV,GAAG,CAACW,KAAJ,CAAU,GAAV,CAAvF;;AACA,QAAID,MAAM,KAAK,CAAf,EAAkB;AACd,YAAM,IAAIb,UAAJ,CAAe,qBAAf,CAAN;AACH;;AACD,UAAMe,SAAS,SAAShB,gBAAgB,CAAC;AACrCY,MAAAA,UADqC;AAErCD,MAAAA,EAAE,EAAGA,EAAE,IAAIM,SAF0B;AAGrCC,MAAAA,SAAS,EAAET,eAAe,IAAIQ,SAHO;AAIrCJ,MAAAA,GAAG,EAAGA,GAAG,IAAII,SAJwB;AAKrCE,MAAAA,aAAa,EAAET,YAAY,IAAIO;AALM,KAAD,EAMrCZ,GANqC,EAMhCC,OANgC,CAAxC;AAOA,UAAMc,MAAM,GAAG;AAAEC,MAAAA,SAAS,EAAEL,SAAS,CAACK,SAAvB;AAAkCZ,MAAAA,eAAe,EAAEO,SAAS,CAACP;AAA7D,KAAf;;AACA,QAAI,OAAOJ,GAAP,KAAe,UAAnB,EAA+B;AAC3B,aAAO,EAAE,GAAGe,MAAL;AAAaf,QAAAA,GAAG,EAAEW,SAAS,CAACX;AAA5B,OAAP;AACH;;AACD,WAAOe,MAAP;AACH,G","sourcesContent":["import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await flattenedDecrypt({\n        ciphertext,\n        iv: (iv || undefined),\n        protected: protectedHeader || undefined,\n        tag: (tag || undefined),\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}