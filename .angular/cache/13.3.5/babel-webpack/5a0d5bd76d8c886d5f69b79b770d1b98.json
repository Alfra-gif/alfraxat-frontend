{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';\nimport { fromSPKI as importPublic } from '../runtime/asn1.js';\nimport { fromPKCS8 as importPrivate } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport formatPEM from '../lib/format_pem.js';\nimport isObject from '../lib/is_object.js';\n\nfunction getElement(seq) {\n  let result = [];\n  let next = 0;\n\n  while (next < seq.length) {\n    let nextPart = parseElement(seq.subarray(next));\n    result.push(nextPart);\n    next += nextPart.byteLength;\n  }\n\n  return result;\n}\n\nfunction parseElement(bytes) {\n  let position = 0;\n  let tag = bytes[0] & 0x1f;\n  position++;\n\n  if (tag === 0x1f) {\n    tag = 0;\n\n    while (bytes[position] >= 0x80) {\n      tag = tag * 128 + bytes[position] - 0x80;\n      position++;\n    }\n\n    tag = tag * 128 + bytes[position] - 0x80;\n    position++;\n  }\n\n  let length = 0;\n\n  if (bytes[position] < 0x80) {\n    length = bytes[position];\n    position++;\n  } else {\n    let numberOfDigits = bytes[position] & 0x7f;\n    position++;\n    length = 0;\n\n    for (let i = 0; i < numberOfDigits; i++) {\n      length = length * 256 + bytes[position];\n      position++;\n    }\n  }\n\n  if (length === 0x80) {\n    length = 0;\n\n    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n      length++;\n    }\n\n    const byteLength = position + length + 2;\n    return {\n      byteLength,\n      contents: bytes.subarray(position, position + length),\n      raw: bytes.subarray(0, byteLength)\n    };\n  }\n\n  const byteLength = position + length;\n  return {\n    byteLength,\n    contents: bytes.subarray(position, byteLength),\n    raw: bytes.subarray(0, byteLength)\n  };\n}\n\nfunction spkiFromX509(buf) {\n  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\n\nfunction getSPKI(x509) {\n  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n  const raw = decodeBase64(pem);\n  return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\n\nexport function importSPKI(_x, _x2, _x3) {\n  return _importSPKI.apply(this, arguments);\n}\n\nfunction _importSPKI() {\n  _importSPKI = _asyncToGenerator(function* (spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n      throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n\n    return importPublic(spki, alg, options);\n  });\n  return _importSPKI.apply(this, arguments);\n}\n\nexport function importX509(_x4, _x5, _x6) {\n  return _importX.apply(this, arguments);\n}\n\nfunction _importX() {\n  _importX = _asyncToGenerator(function* (x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n      throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n\n    const spki = getSPKI(x509);\n    return importPublic(spki, alg, options);\n  });\n  return _importX.apply(this, arguments);\n}\n\nexport function importPKCS8(_x7, _x8, _x9) {\n  return _importPKCS.apply(this, arguments);\n}\n\nfunction _importPKCS() {\n  _importPKCS = _asyncToGenerator(function* (pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n      throw new TypeError('\"pkcs8\" must be PCKS8 formatted string');\n    }\n\n    return importPrivate(pkcs8, alg, options);\n  });\n  return _importPKCS.apply(this, arguments);\n}\n\nexport function importJWK(_x10, _x11, _x12) {\n  return _importJWK.apply(this, arguments);\n}\n\nfunction _importJWK() {\n  _importJWK = _asyncToGenerator(function* (jwk, alg, octAsKeyObject) {\n    if (!isObject(jwk)) {\n      throw new TypeError('JWK must be an object');\n    }\n\n    alg || (alg = jwk.alg);\n\n    if (typeof alg !== 'string' || !alg) {\n      throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n\n    switch (jwk.kty) {\n      case 'oct':\n        if (typeof jwk.k !== 'string' || !jwk.k) {\n          throw new TypeError('missing \"k\" (Key Value) Parameter value');\n        }\n\n        octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;\n\n        if (octAsKeyObject) {\n          return asKeyObject({ ...jwk,\n            alg,\n            ext: false\n          });\n        }\n\n        return decodeBase64URL(jwk.k);\n\n      case 'RSA':\n        if (jwk.oth !== undefined) {\n          throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n        }\n\n      case 'EC':\n      case 'OKP':\n        return asKeyObject({ ...jwk,\n          alg\n        });\n\n      default:\n        throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n  });\n  return _importJWK.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/key/import.js"],"names":["decode","decodeBase64URL","encodeBase64","decodeBase64","fromSPKI","importPublic","fromPKCS8","importPrivate","asKeyObject","JOSENotSupported","formatPEM","isObject","getElement","seq","result","next","length","nextPart","parseElement","subarray","push","byteLength","bytes","position","tag","numberOfDigits","i","contents","raw","spkiFromX509","buf","tbsCertificate","getSPKI","x509","pem","replace","importSPKI","spki","alg","options","indexOf","TypeError","importX509","importPKCS8","pkcs8","importJWK","jwk","octAsKeyObject","kty","k","ext","oth","undefined"],"mappings":"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","sourcesContent":["import { decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';\nimport { fromSPKI as importPublic } from '../runtime/asn1.js';\nimport { fromPKCS8 as importPrivate } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport formatPEM from '../lib/format_pem.js';\nimport isObject from '../lib/is_object.js';\nfunction getElement(seq) {\n    let result = [];\n    let next = 0;\n    while (next < seq.length) {\n        let nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else {\n        let numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = decodeBase64(pem);\n    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return importPublic(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    const spki = getSPKI(x509);\n    return importPublic(spki, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PCKS8 formatted string');\n    }\n    return importPrivate(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, octAsKeyObject) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    if (typeof alg !== 'string' || !alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return asKeyObject({ ...jwk, alg, ext: false });\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n"]},"metadata":{},"sourceType":"module"}