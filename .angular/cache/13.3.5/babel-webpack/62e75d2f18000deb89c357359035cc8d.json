{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport function flattenedVerify(_x, _x2, _x3) {\n  return _flattenedVerify.apply(this, arguments);\n}\n\nfunction _flattenedVerify() {\n  _flattenedVerify = _asyncToGenerator(function* (jws, key, options) {\n    var _a;\n\n    if (!isObject(jws)) {\n      throw new JWSInvalid('Flattened JWS must be an object');\n    }\n\n    if (jws.protected === undefined && jws.header === undefined) {\n      throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n      throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n\n    if (jws.payload === undefined) {\n      throw new JWSInvalid('JWS Payload missing');\n    }\n\n    if (typeof jws.signature !== 'string') {\n      throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n\n    if (jws.header !== undefined && !isObject(jws.header)) {\n      throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n\n    let parsedProt = {};\n\n    if (jws.protected) {\n      const protectedHeader = base64url(jws.protected);\n\n      try {\n        parsedProt = JSON.parse(decoder.decode(protectedHeader));\n      } catch (_b) {\n        throw new JWSInvalid('JWS Protected Header is invalid');\n      }\n    }\n\n    if (!isDisjoint(parsedProt, jws.header)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    const joseHeader = { ...parsedProt,\n      ...jws.header\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n\n    if (extensions.has('b64')) {\n      b64 = parsedProt.b64;\n\n      if (typeof b64 !== 'boolean') {\n        throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n      }\n    }\n\n    const {\n      alg\n    } = joseHeader;\n\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n\n    if (algorithms && !algorithms.has(alg)) {\n      throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n\n    if (b64) {\n      if (typeof jws.payload !== 'string') {\n        throw new JWSInvalid('JWS Payload must be a string');\n      }\n    } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n      throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n\n    let resolvedKey = false;\n\n    if (typeof key === 'function') {\n      key = yield key(parsedProt, jws);\n      resolvedKey = true;\n    }\n\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = base64url(jws.signature);\n    const verified = yield verify(alg, key, signature, data);\n\n    if (!verified) {\n      throw new JWSSignatureVerificationFailed();\n    }\n\n    let payload;\n\n    if (b64) {\n      payload = base64url(jws.payload);\n    } else if (typeof jws.payload === 'string') {\n      payload = encoder.encode(jws.payload);\n    } else {\n      payload = jws.payload;\n    }\n\n    const result = {\n      payload\n    };\n\n    if (jws.protected !== undefined) {\n      result.protectedHeader = parsedProt;\n    }\n\n    if (jws.header !== undefined) {\n      result.unprotectedHeader = jws.header;\n    }\n\n    if (resolvedKey) {\n      return { ...result,\n        key\n      };\n    }\n\n    return result;\n  });\n  return _flattenedVerify.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/jws/flattened/verify.js"],"names":["decode","base64url","verify","JOSEAlgNotAllowed","JWSInvalid","JWSSignatureVerificationFailed","concat","encoder","decoder","isDisjoint","isObject","checkKeyType","validateCrit","validateAlgorithms","flattenedVerify","jws","key","options","_a","protected","undefined","header","payload","signature","parsedProt","protectedHeader","JSON","parse","_b","joseHeader","extensions","Map","crit","b64","has","alg","algorithms","Uint8Array","resolvedKey","data","encode","verified","result","unprotectedHeader"],"mappings":"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","sourcesContent":["import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        const protectedHeader = base64url(jws.protected);\n        try {\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = base64url(jws.signature);\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = base64url(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}