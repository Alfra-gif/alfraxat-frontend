{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport bogusWebCrypto from './bogus.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\n\nfunction checkKeySize(key, alg) {\n  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {\n    throw new TypeError(`Invalid key size for alg: ${alg}`);\n  }\n}\n\nfunction getCryptoKey(key, alg, usage) {\n  if (isCryptoKey(key)) {\n    checkEncCryptoKey(key, alg, usage);\n    return key;\n  }\n\n  if (key instanceof Uint8Array) {\n    return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n  }\n\n  throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\n\nexport const wrap = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (alg, key, cek) {\n    const cryptoKey = yield getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = yield crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n    return new Uint8Array(yield crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n  });\n\n  return function wrap(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport const unwrap = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (alg, key, encryptedKey) {\n    const cryptoKey = yield getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = yield crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);\n    return new Uint8Array(yield crypto.subtle.exportKey('raw', cryptoKeyCek));\n  });\n\n  return function unwrap(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/runtime/aeskw.js"],"names":["bogusWebCrypto","crypto","isCryptoKey","checkEncCryptoKey","invalidKeyInput","types","checkKeySize","key","alg","algorithm","length","parseInt","slice","TypeError","getCryptoKey","usage","Uint8Array","subtle","importKey","wrap","cek","cryptoKey","cryptoKeyCek","wrapKey","unwrap","encryptedKey","unwrapKey","exportKey"],"mappings":";AAAA,OAAOA,cAAP,MAA2B,YAA3B;AACA,OAAOC,MAAP,IAAiBC,WAAjB,QAAoC,gBAApC;AACA,SAASC,iBAAT,QAAkC,sBAAlC;AACA,OAAOC,eAAP,MAA4B,6BAA5B;AACA,SAASC,KAAT,QAAsB,kBAAtB;;AACA,SAASC,YAAT,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;AAC5B,MAAID,GAAG,CAACE,SAAJ,CAAcC,MAAd,KAAyBC,QAAQ,CAACH,GAAG,CAACI,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAD,EAAkB,EAAlB,CAArC,EAA4D;AACxD,UAAM,IAAIC,SAAJ,CAAe,6BAA4BL,GAAI,EAA/C,CAAN;AACH;AACJ;;AACD,SAASM,YAAT,CAAsBP,GAAtB,EAA2BC,GAA3B,EAAgCO,KAAhC,EAAuC;AACnC,MAAIb,WAAW,CAACK,GAAD,CAAf,EAAsB;AAClBJ,IAAAA,iBAAiB,CAACI,GAAD,EAAMC,GAAN,EAAWO,KAAX,CAAjB;AACA,WAAOR,GAAP;AACH;;AACD,MAAIA,GAAG,YAAYS,UAAnB,EAA+B;AAC3B,WAAOf,MAAM,CAACgB,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BX,GAA/B,EAAoC,QAApC,EAA8C,IAA9C,EAAoD,CAACQ,KAAD,CAApD,CAAP;AACH;;AACD,QAAM,IAAIF,SAAJ,CAAcT,eAAe,CAACG,GAAD,EAAM,GAAGF,KAAT,EAAgB,YAAhB,CAA7B,CAAN;AACH;;AACD,OAAO,MAAMc,IAAI;AAAA,+BAAG,WAAOX,GAAP,EAAYD,GAAZ,EAAiBa,GAAjB,EAAyB;AACzC,UAAMC,SAAS,SAASP,YAAY,CAACP,GAAD,EAAMC,GAAN,EAAW,SAAX,CAApC;AACAF,IAAAA,YAAY,CAACe,SAAD,EAAYb,GAAZ,CAAZ;AACA,UAAMc,YAAY,SAASrB,MAAM,CAACgB,MAAP,CAAcC,SAAd,CAAwB,KAAxB,EAA+BE,GAA/B,EAAoC,GAAGpB,cAAvC,CAA3B;AACA,WAAO,IAAIgB,UAAJ,OAAqBf,MAAM,CAACgB,MAAP,CAAcM,OAAd,CAAsB,KAAtB,EAA6BD,YAA7B,EAA2CD,SAA3C,EAAsD,QAAtD,CAArB,CAAP;AACH,GALgB;;AAAA,kBAAJF,IAAI;AAAA;AAAA;AAAA,GAAV;AAMP,OAAO,MAAMK,MAAM;AAAA,gCAAG,WAAOhB,GAAP,EAAYD,GAAZ,EAAiBkB,YAAjB,EAAkC;AACpD,UAAMJ,SAAS,SAASP,YAAY,CAACP,GAAD,EAAMC,GAAN,EAAW,WAAX,CAApC;AACAF,IAAAA,YAAY,CAACe,SAAD,EAAYb,GAAZ,CAAZ;AACA,UAAMc,YAAY,SAASrB,MAAM,CAACgB,MAAP,CAAcS,SAAd,CAAwB,KAAxB,EAA+BD,YAA/B,EAA6CJ,SAA7C,EAAwD,QAAxD,EAAkE,GAAGrB,cAArE,CAA3B;AACA,WAAO,IAAIgB,UAAJ,OAAqBf,MAAM,CAACgB,MAAP,CAAcU,SAAd,CAAwB,KAAxB,EAA+BL,YAA/B,CAArB,CAAP;AACH,GALkB;;AAAA,kBAANE,MAAM;AAAA;AAAA;AAAA,GAAZ","sourcesContent":["import bogusWebCrypto from './bogus.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey(key, alg, usage) {\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const wrap = async (alg, key, cek) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\nexport const unwrap = async (alg, key, encryptedKey) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n};\n"]},"metadata":{},"sourceType":"module"}