{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport function deriveKey(_x, _x2, _x3, _x4) {\n  return _deriveKey.apply(this, arguments);\n}\n\nfunction _deriveKey() {\n  _deriveKey = _asyncToGenerator(function* (publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    if (!isCryptoKey(publicKey)) {\n      throw new TypeError(invalidKeyInput(publicKey, ...types));\n    }\n\n    checkEncCryptoKey(publicKey, 'ECDH');\n\n    if (!isCryptoKey(privateKey)) {\n      throw new TypeError(invalidKeyInput(privateKey, ...types));\n    }\n\n    checkEncCryptoKey(privateKey, 'ECDH', 'deriveBits');\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    const sharedSecret = new Uint8Array(yield crypto.subtle.deriveBits({\n      name: 'ECDH',\n      public: publicKey\n    }, privateKey, Math.ceil(parseInt(privateKey.algorithm.namedCurve.slice(-3), 10) / 8) << 3));\n    return concatKdf(sharedSecret, keyLength, value);\n  });\n  return _deriveKey.apply(this, arguments);\n}\n\nexport function generateEpk(_x5) {\n  return _generateEpk.apply(this, arguments);\n}\n\nfunction _generateEpk() {\n  _generateEpk = _asyncToGenerator(function* (key) {\n    if (!isCryptoKey(key)) {\n      throw new TypeError(invalidKeyInput(key, ...types));\n    }\n\n    return crypto.subtle.generateKey(key.algorithm, true, ['deriveBits']);\n  });\n  return _generateEpk.apply(this, arguments);\n}\n\nexport function ecdhAllowed(key) {\n  if (!isCryptoKey(key)) {\n    throw new TypeError(invalidKeyInput(key, ...types));\n  }\n\n  return ['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve);\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/runtime/ecdhes.js"],"names":["encoder","concat","uint32be","lengthAndInput","concatKdf","crypto","isCryptoKey","checkEncCryptoKey","invalidKeyInput","types","deriveKey","publicKey","privateKey","algorithm","keyLength","apu","Uint8Array","apv","TypeError","value","encode","sharedSecret","subtle","deriveBits","name","public","Math","ceil","parseInt","namedCurve","slice","generateEpk","key","generateKey","ecdhAllowed","includes"],"mappings":";AAAA,SAASA,OAAT,EAAkBC,MAAlB,EAA0BC,QAA1B,EAAoCC,cAApC,EAAoDC,SAApD,QAAqE,wBAArE;AACA,OAAOC,MAAP,IAAiBC,WAAjB,QAAoC,gBAApC;AACA,SAASC,iBAAT,QAAkC,sBAAlC;AACA,OAAOC,eAAP,MAA4B,6BAA5B;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,gBAAsBC,SAAtB;AAAA;AAAA;;;iCAAO,WAAyBC,SAAzB,EAAoCC,UAApC,EAAgDC,SAAhD,EAA2DC,SAA3D,EAAsEC,GAAG,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAA5E,EAA+FC,GAAG,GAAG,IAAID,UAAJ,CAAe,CAAf,CAArG,EAAwH;AAC3H,QAAI,CAACV,WAAW,CAACK,SAAD,CAAhB,EAA6B;AACzB,YAAM,IAAIO,SAAJ,CAAcV,eAAe,CAACG,SAAD,EAAY,GAAGF,KAAf,CAA7B,CAAN;AACH;;AACDF,IAAAA,iBAAiB,CAACI,SAAD,EAAY,MAAZ,CAAjB;;AACA,QAAI,CAACL,WAAW,CAACM,UAAD,CAAhB,EAA8B;AAC1B,YAAM,IAAIM,SAAJ,CAAcV,eAAe,CAACI,UAAD,EAAa,GAAGH,KAAhB,CAA7B,CAAN;AACH;;AACDF,IAAAA,iBAAiB,CAACK,UAAD,EAAa,MAAb,EAAqB,YAArB,CAAjB;AACA,UAAMO,KAAK,GAAGlB,MAAM,CAACE,cAAc,CAACH,OAAO,CAACoB,MAAR,CAAeP,SAAf,CAAD,CAAf,EAA4CV,cAAc,CAACY,GAAD,CAA1D,EAAiEZ,cAAc,CAACc,GAAD,CAA/E,EAAsFf,QAAQ,CAACY,SAAD,CAA9F,CAApB;AACA,UAAMO,YAAY,GAAG,IAAIL,UAAJ,OAAqBX,MAAM,CAACiB,MAAP,CAAcC,UAAd,CAAyB;AAC/DC,MAAAA,IAAI,EAAE,MADyD;AAE/DC,MAAAA,MAAM,EAAEd;AAFuD,KAAzB,EAGvCC,UAHuC,EAG3Bc,IAAI,CAACC,IAAL,CAAUC,QAAQ,CAAChB,UAAU,CAACC,SAAX,CAAqBgB,UAArB,CAAgCC,KAAhC,CAAsC,CAAC,CAAvC,CAAD,EAA4C,EAA5C,CAAR,GAA0D,CAApE,KAA0E,CAH/C,CAArB,CAArB;AAIA,WAAO1B,SAAS,CAACiB,YAAD,EAAeP,SAAf,EAA0BK,KAA1B,CAAhB;AACH,G;;;;AACD,gBAAsBY,WAAtB;AAAA;AAAA;;;mCAAO,WAA2BC,GAA3B,EAAgC;AACnC,QAAI,CAAC1B,WAAW,CAAC0B,GAAD,CAAhB,EAAuB;AACnB,YAAM,IAAId,SAAJ,CAAcV,eAAe,CAACwB,GAAD,EAAM,GAAGvB,KAAT,CAA7B,CAAN;AACH;;AACD,WAAOJ,MAAM,CAACiB,MAAP,CAAcW,WAAd,CAA0BD,GAAG,CAACnB,SAA9B,EAAyC,IAAzC,EAA+C,CAAC,YAAD,CAA/C,CAAP;AACH,G;;;;AACD,OAAO,SAASqB,WAAT,CAAqBF,GAArB,EAA0B;AAC7B,MAAI,CAAC1B,WAAW,CAAC0B,GAAD,CAAhB,EAAuB;AACnB,UAAM,IAAId,SAAJ,CAAcV,eAAe,CAACwB,GAAD,EAAM,GAAGvB,KAAT,CAA7B,CAAN;AACH;;AACD,SAAO,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,EAA4B0B,QAA5B,CAAqCH,GAAG,CAACnB,SAAJ,CAAcgB,UAAnD,CAAP;AACH","sourcesContent":["import { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    if (!isCryptoKey(publicKey)) {\n        throw new TypeError(invalidKeyInput(publicKey, ...types));\n    }\n    checkEncCryptoKey(publicKey, 'ECDH');\n    if (!isCryptoKey(privateKey)) {\n        throw new TypeError(invalidKeyInput(privateKey, ...types));\n    }\n    checkEncCryptoKey(privateKey, 'ECDH', 'deriveBits');\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    const sharedSecret = new Uint8Array(await crypto.subtle.deriveBits({\n        name: 'ECDH',\n        public: publicKey,\n    }, privateKey, Math.ceil(parseInt(privateKey.algorithm.namedCurve.slice(-3), 10) / 8) << 3));\n    return concatKdf(sharedSecret, keyLength, value);\n}\nexport async function generateEpk(key) {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    return crypto.subtle.generateKey(key.algorithm, true, ['deriveBits']);\n}\nexport function ecdhAllowed(key) {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    return ['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve);\n}\n"]},"metadata":{},"sourceType":"module"}