{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\n\nclass IndividualRecipient {\n  constructor(enc, key, options) {\n    this.parent = enc;\n    this.key = key;\n    this.options = options;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this.unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this.unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  addRecipient(...args) {\n    return this.parent.addRecipient(...args);\n  }\n\n  encrypt(...args) {\n    return this.parent.encrypt(...args);\n  }\n\n  done() {\n    return this.parent;\n  }\n\n}\n\nexport class GeneralEncrypt {\n  constructor(plaintext) {\n    this._recipients = [];\n    this._plaintext = plaintext;\n  }\n\n  addRecipient(key, options) {\n    const recipient = new IndividualRecipient(this, key, {\n      crit: options === null || options === void 0 ? void 0 : options.crit\n    });\n\n    this._recipients.push(recipient);\n\n    return recipient;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setSharedUnprotectedHeader can only be called once');\n    }\n\n    this._unprotectedHeader = sharedUnprotectedHeader;\n    return this;\n  }\n\n  setAdditionalAuthenticatedData(aad) {\n    this._aad = aad;\n    return this;\n  }\n\n  encrypt(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      if (!_this._recipients.length) {\n        throw new JWEInvalid('at least one recipient must be added');\n      }\n\n      options = {\n        deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw\n      };\n\n      if (_this._recipients.length === 1) {\n        const [recipient] = _this._recipients;\n        const flattened = yield new FlattenedEncrypt(_this._plaintext).setAdditionalAuthenticatedData(_this._aad).setProtectedHeader(_this._protectedHeader).setSharedUnprotectedHeader(_this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options,\n          ...options\n        });\n        let jwe = {\n          ciphertext: flattened.ciphertext,\n          iv: flattened.iv,\n          recipients: [{}],\n          tag: flattened.tag\n        };\n        if (flattened.aad) jwe.aad = flattened.aad;\n        if (flattened.protected) jwe.protected = flattened.protected;\n        if (flattened.unprotected) jwe.unprotected = flattened.unprotected;\n        if (flattened.encrypted_key) jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n        if (flattened.header) jwe.recipients[0].header = flattened.header;\n        return jwe;\n      }\n\n      let enc;\n\n      for (let i = 0; i < _this._recipients.length; i++) {\n        const recipient = _this._recipients[i];\n\n        if (!isDisjoint(_this._protectedHeader, _this._unprotectedHeader, recipient.unprotectedHeader)) {\n          throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n\n        const joseHeader = { ..._this._protectedHeader,\n          ..._this._unprotectedHeader,\n          ...recipient.unprotectedHeader\n        };\n        const {\n          alg\n        } = joseHeader;\n\n        if (typeof alg !== 'string' || !alg) {\n          throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n\n        if (alg === 'dir' || alg === 'ECDH-ES') {\n          throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n        }\n\n        if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n          throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n\n        if (!enc) {\n          enc = joseHeader.enc;\n        } else if (enc !== joseHeader.enc) {\n          throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n        }\n\n        validateCrit(JWEInvalid, new Map(), recipient.options.crit, _this._protectedHeader, joseHeader);\n\n        if (joseHeader.zip !== undefined) {\n          if (!_this._protectedHeader || !_this._protectedHeader.zip) {\n            throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n          }\n        }\n      }\n\n      const cek = generateCek(enc);\n      let jwe = {\n        ciphertext: '',\n        iv: '',\n        recipients: [],\n        tag: ''\n      };\n\n      for (let i = 0; i < _this._recipients.length; i++) {\n        const recipient = _this._recipients[i];\n        const target = {};\n        jwe.recipients.push(target);\n        const joseHeader = { ..._this._protectedHeader,\n          ..._this._unprotectedHeader,\n          ...recipient.unprotectedHeader\n        };\n        const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n\n        if (i === 0) {\n          const flattened = yield new FlattenedEncrypt(_this._plaintext).setAdditionalAuthenticatedData(_this._aad).setContentEncryptionKey(cek).setProtectedHeader(_this._protectedHeader).setSharedUnprotectedHeader(_this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({\n            p2c\n          }).encrypt(recipient.key, { ...recipient.options,\n            ...options,\n            [unprotected]: true\n          });\n          jwe.ciphertext = flattened.ciphertext;\n          jwe.iv = flattened.iv;\n          jwe.tag = flattened.tag;\n          if (flattened.aad) jwe.aad = flattened.aad;\n          if (flattened.protected) jwe.protected = flattened.protected;\n          if (flattened.unprotected) jwe.unprotected = flattened.unprotected;\n          target.encrypted_key = flattened.encrypted_key;\n          if (flattened.header) target.header = flattened.header;\n          continue;\n        }\n\n        const {\n          encryptedKey,\n          parameters\n        } = yield encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = _this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = _this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, {\n          p2c\n        });\n        target.encrypted_key = base64url(encryptedKey);\n        if (recipient.unprotectedHeader || parameters) target.header = { ...recipient.unprotectedHeader,\n          ...parameters\n        };\n      }\n\n      return jwe;\n    })();\n  }\n\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/jwe/general/encrypt.js"],"names":["FlattenedEncrypt","unprotected","JWEInvalid","generateCek","isDisjoint","encryptKeyManagement","encode","base64url","validateCrit","IndividualRecipient","constructor","enc","key","options","parent","setUnprotectedHeader","unprotectedHeader","TypeError","addRecipient","args","encrypt","done","GeneralEncrypt","plaintext","_recipients","_plaintext","recipient","crit","push","setProtectedHeader","protectedHeader","_protectedHeader","setSharedUnprotectedHeader","sharedUnprotectedHeader","_unprotectedHeader","setAdditionalAuthenticatedData","aad","_aad","_a","_b","_c","length","deflateRaw","flattened","jwe","ciphertext","iv","recipients","tag","protected","encrypted_key","header","i","joseHeader","alg","Map","zip","undefined","cek","target","p2c","startsWith","setContentEncryptionKey","setKeyManagementParameters","encryptedKey","parameters"],"mappings":"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","sourcesContent":["import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b, _c;\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = generateCek(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    ...options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||\n                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||\n                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}