{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n  const size = buffers.reduce((acc, {\n    length\n  }) => acc + length, 0);\n  const buf = new Uint8Array(size);\n  let i = 0;\n  buffers.forEach(buffer => {\n    buf.set(buffer, i);\n    i += buffer.length;\n  });\n  return buf;\n}\nexport function p2s(alg, p2sInput) {\n  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\n\nfunction writeUInt32BE(buf, value, offset) {\n  if (value < 0 || value >= MAX_INT32) {\n    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n  }\n\n  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\n\nexport function uint64be(value) {\n  const high = Math.floor(value / MAX_INT32);\n  const low = value % MAX_INT32;\n  const buf = new Uint8Array(8);\n  writeUInt32BE(buf, high, 0);\n  writeUInt32BE(buf, low, 4);\n  return buf;\n}\nexport function uint32be(value) {\n  const buf = new Uint8Array(4);\n  writeUInt32BE(buf, value);\n  return buf;\n}\nexport function lengthAndInput(input) {\n  return concat(uint32be(input.length), input);\n}\nexport function concatKdf(_x, _x2, _x3) {\n  return _concatKdf.apply(this, arguments);\n}\n\nfunction _concatKdf() {\n  _concatKdf = _asyncToGenerator(function* (secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n\n    for (let iter = 0; iter < iterations; iter++) {\n      const buf = new Uint8Array(4 + secret.length + value.length);\n      buf.set(uint32be(iter + 1));\n      buf.set(secret, 4);\n      buf.set(value, 4 + secret.length);\n      res.set(yield digest('sha256', buf), iter * 32);\n    }\n\n    return res.slice(0, bits >> 3);\n  });\n  return _concatKdf.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/lib/buffer_utils.js"],"names":["digest","encoder","TextEncoder","decoder","TextDecoder","MAX_INT32","concat","buffers","size","reduce","acc","length","buf","Uint8Array","i","forEach","buffer","set","p2s","alg","p2sInput","encode","writeUInt32BE","value","offset","RangeError","uint64be","high","Math","floor","low","uint32be","lengthAndInput","input","concatKdf","secret","bits","iterations","ceil","res","iter","slice"],"mappings":";AAAA,OAAOA,MAAP,MAAmB,sBAAnB;AACA,OAAO,MAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACP,OAAO,MAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACP,MAAMC,SAAS,GAAG,KAAK,EAAvB;AACA,OAAO,SAASC,MAAT,CAAgB,GAAGC,OAAnB,EAA4B;AAC/B,QAAMC,IAAI,GAAGD,OAAO,CAACE,MAAR,CAAe,CAACC,GAAD,EAAM;AAAEC,IAAAA;AAAF,GAAN,KAAqBD,GAAG,GAAGC,MAA1C,EAAkD,CAAlD,CAAb;AACA,QAAMC,GAAG,GAAG,IAAIC,UAAJ,CAAeL,IAAf,CAAZ;AACA,MAAIM,CAAC,GAAG,CAAR;AACAP,EAAAA,OAAO,CAACQ,OAAR,CAAiBC,MAAD,IAAY;AACxBJ,IAAAA,GAAG,CAACK,GAAJ,CAAQD,MAAR,EAAgBF,CAAhB;AACAA,IAAAA,CAAC,IAAIE,MAAM,CAACL,MAAZ;AACH,GAHD;AAIA,SAAOC,GAAP;AACH;AACD,OAAO,SAASM,GAAT,CAAaC,GAAb,EAAkBC,QAAlB,EAA4B;AAC/B,SAAOd,MAAM,CAACL,OAAO,CAACoB,MAAR,CAAeF,GAAf,CAAD,EAAsB,IAAIN,UAAJ,CAAe,CAAC,CAAD,CAAf,CAAtB,EAA2CO,QAA3C,CAAb;AACH;;AACD,SAASE,aAAT,CAAuBV,GAAvB,EAA4BW,KAA5B,EAAmCC,MAAnC,EAA2C;AACvC,MAAID,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAIlB,SAA1B,EAAqC;AACjC,UAAM,IAAIoB,UAAJ,CAAgB,6BAA4BpB,SAAS,GAAG,CAAE,cAAakB,KAAM,EAA7E,CAAN;AACH;;AACDX,EAAAA,GAAG,CAACK,GAAJ,CAAQ,CAACM,KAAK,KAAK,EAAX,EAAeA,KAAK,KAAK,EAAzB,EAA6BA,KAAK,KAAK,CAAvC,EAA0CA,KAAK,GAAG,IAAlD,CAAR,EAAiEC,MAAjE;AACH;;AACD,OAAO,SAASE,QAAT,CAAkBH,KAAlB,EAAyB;AAC5B,QAAMI,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWN,KAAK,GAAGlB,SAAnB,CAAb;AACA,QAAMyB,GAAG,GAAGP,KAAK,GAAGlB,SAApB;AACA,QAAMO,GAAG,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAZ;AACAS,EAAAA,aAAa,CAACV,GAAD,EAAMe,IAAN,EAAY,CAAZ,CAAb;AACAL,EAAAA,aAAa,CAACV,GAAD,EAAMkB,GAAN,EAAW,CAAX,CAAb;AACA,SAAOlB,GAAP;AACH;AACD,OAAO,SAASmB,QAAT,CAAkBR,KAAlB,EAAyB;AAC5B,QAAMX,GAAG,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAZ;AACAS,EAAAA,aAAa,CAACV,GAAD,EAAMW,KAAN,CAAb;AACA,SAAOX,GAAP;AACH;AACD,OAAO,SAASoB,cAAT,CAAwBC,KAAxB,EAA+B;AAClC,SAAO3B,MAAM,CAACyB,QAAQ,CAACE,KAAK,CAACtB,MAAP,CAAT,EAAyBsB,KAAzB,CAAb;AACH;AACD,gBAAsBC,SAAtB;AAAA;AAAA;;;iCAAO,WAAyBC,MAAzB,EAAiCC,IAAjC,EAAuCb,KAAvC,EAA8C;AACjD,UAAMc,UAAU,GAAGT,IAAI,CAACU,IAAL,CAAU,CAACF,IAAI,IAAI,CAAT,IAAc,EAAxB,CAAnB;AACA,UAAMG,GAAG,GAAG,IAAI1B,UAAJ,CAAewB,UAAU,GAAG,EAA5B,CAAZ;;AACA,SAAK,IAAIG,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGH,UAA1B,EAAsCG,IAAI,EAA1C,EAA8C;AAC1C,YAAM5B,GAAG,GAAG,IAAIC,UAAJ,CAAe,IAAIsB,MAAM,CAACxB,MAAX,GAAoBY,KAAK,CAACZ,MAAzC,CAAZ;AACAC,MAAAA,GAAG,CAACK,GAAJ,CAAQc,QAAQ,CAACS,IAAI,GAAG,CAAR,CAAhB;AACA5B,MAAAA,GAAG,CAACK,GAAJ,CAAQkB,MAAR,EAAgB,CAAhB;AACAvB,MAAAA,GAAG,CAACK,GAAJ,CAAQM,KAAR,EAAe,IAAIY,MAAM,CAACxB,MAA1B;AACA4B,MAAAA,GAAG,CAACtB,GAAJ,OAAcjB,MAAM,CAAC,QAAD,EAAWY,GAAX,CAApB,EAAqC4B,IAAI,GAAG,EAA5C;AACH;;AACD,WAAOD,GAAG,CAACE,KAAJ,CAAU,CAAV,EAAaL,IAAI,IAAI,CAArB,CAAP;AACH,G","sourcesContent":["import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n"]},"metadata":{},"sourceType":"module"}