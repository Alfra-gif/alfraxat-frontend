{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n  setProtectedHeader(protectedHeader) {\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  sign(key, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const sig = new CompactSign(encoder.encode(JSON.stringify(_this._payload)));\n      sig.setProtectedHeader(_this._protectedHeader);\n\n      if (Array.isArray((_a = _this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && _this._protectedHeader.crit.includes('b64') && _this._protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n      }\n\n      return sig.sign(key, options);\n    })();\n  }\n\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/jwt/sign.js"],"names":["CompactSign","JWTInvalid","encoder","ProduceJWT","SignJWT","setProtectedHeader","protectedHeader","_protectedHeader","sign","key","options","_a","sig","encode","JSON","stringify","_payload","Array","isArray","crit","includes","b64"],"mappings":";AAAA,SAASA,WAAT,QAA4B,wBAA5B;AACA,SAASC,UAAT,QAA2B,mBAA3B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,OAAO,MAAMC,OAAN,SAAsBD,UAAtB,CAAiC;AACpCE,EAAAA,kBAAkB,CAACC,eAAD,EAAkB;AAChC,SAAKC,gBAAL,GAAwBD,eAAxB;AACA,WAAO,IAAP;AACH;;AACKE,EAAAA,IAAI,CAACC,GAAD,EAAMC,OAAN,EAAe;AAAA;;AAAA;AACrB,UAAIC,EAAJ;;AACA,YAAMC,GAAG,GAAG,IAAIZ,WAAJ,CAAgBE,OAAO,CAACW,MAAR,CAAeC,IAAI,CAACC,SAAL,CAAe,KAAI,CAACC,QAApB,CAAf,CAAhB,CAAZ;AACAJ,MAAAA,GAAG,CAACP,kBAAJ,CAAuB,KAAI,CAACE,gBAA5B;;AACA,UAAIU,KAAK,CAACC,OAAN,CAAc,CAACP,EAAE,GAAG,KAAI,CAACJ,gBAAX,MAAiC,IAAjC,IAAyCI,EAAE,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,EAAE,CAACQ,IAAnF,KACA,KAAI,CAACZ,gBAAL,CAAsBY,IAAtB,CAA2BC,QAA3B,CAAoC,KAApC,CADA,IAEA,KAAI,CAACb,gBAAL,CAAsBc,GAAtB,KAA8B,KAFlC,EAEyC;AACrC,cAAM,IAAIpB,UAAJ,CAAe,qCAAf,CAAN;AACH;;AACD,aAAOW,GAAG,CAACJ,IAAJ,CAASC,GAAT,EAAcC,OAAd,CAAP;AATqB;AAUxB;;AAfmC","sourcesContent":["import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        var _a;\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}