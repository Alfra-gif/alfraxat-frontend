{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isCloudflareWorkers, isNodeJs } from './env.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\n\nconst genericExport = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (keyType, keyFormat, key) {\n    if (!isCryptoKey(key)) {\n      throw new TypeError(invalidKeyInput(key, ...types));\n    }\n\n    if (!key.extractable) {\n      throw new TypeError('CryptoKey is not extractable');\n    }\n\n    if (key.type !== keyType) {\n      throw new TypeError(`key is not a ${keyType} key`);\n    }\n\n    return formatPEM(encodeBase64(new Uint8Array(yield crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n  });\n\n  return function genericExport(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport const toSPKI = key => {\n  return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = key => {\n  return genericExport('private', 'pkcs8', key);\n};\n\nconst findOid = (keyData, oid, from = 0) => {\n  if (from === 0) {\n    oid.unshift(oid.length);\n    oid.unshift(0x06);\n  }\n\n  let i = keyData.indexOf(oid[0], from);\n  if (i === -1) return false;\n  const sub = keyData.subarray(i, i + oid.length);\n  if (sub.length !== oid.length) return false;\n  return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\n\nconst getNamedCurve = keyData => {\n  switch (true) {\n    case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n      return 'P-256';\n\n    case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n      return 'P-384';\n\n    case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n      return 'P-521';\n\n    case (isCloudflareWorkers() || isNodeJs()) && findOid(keyData, [0x2b, 0x65, 0x70]):\n      return 'Ed25519';\n\n    case isNodeJs() && findOid(keyData, [0x2b, 0x65, 0x71]):\n      return 'Ed448';\n\n    default:\n      throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n  }\n};\n\nconst genericImport = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (replace, keyFormat, pem, alg, options) {\n    var _a;\n\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, '')).split('').map(c => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n\n    switch (alg) {\n      case 'PS256':\n      case 'PS384':\n      case 'PS512':\n        algorithm = {\n          name: 'RSA-PSS',\n          hash: `SHA-${alg.slice(-3)}`\n        };\n        keyUsages = isPublic ? ['verify'] : ['sign'];\n        break;\n\n      case 'RS256':\n      case 'RS384':\n      case 'RS512':\n        algorithm = {\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: `SHA-${alg.slice(-3)}`\n        };\n        keyUsages = isPublic ? ['verify'] : ['sign'];\n        break;\n\n      case 'RSA-OAEP':\n      case 'RSA-OAEP-256':\n      case 'RSA-OAEP-384':\n      case 'RSA-OAEP-512':\n        algorithm = {\n          name: 'RSA-OAEP',\n          hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`\n        };\n        keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n        break;\n\n      case 'ES256':\n        algorithm = {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        };\n        keyUsages = isPublic ? ['verify'] : ['sign'];\n        break;\n\n      case 'ES384':\n        algorithm = {\n          name: 'ECDSA',\n          namedCurve: 'P-384'\n        };\n        keyUsages = isPublic ? ['verify'] : ['sign'];\n        break;\n\n      case 'ES512':\n        algorithm = {\n          name: 'ECDSA',\n          namedCurve: 'P-521'\n        };\n        keyUsages = isPublic ? ['verify'] : ['sign'];\n        break;\n\n      case 'ECDH-ES':\n      case 'ECDH-ES+A128KW':\n      case 'ECDH-ES+A192KW':\n      case 'ECDH-ES+A256KW':\n        algorithm = {\n          name: 'ECDH',\n          namedCurve: getNamedCurve(keyData)\n        };\n        keyUsages = isPublic ? [] : ['deriveBits'];\n        break;\n\n      case (isCloudflareWorkers() || isNodeJs()) && 'EdDSA':\n        const namedCurve = getNamedCurve(keyData).toUpperCase();\n        algorithm = {\n          name: `NODE-${namedCurve}`,\n          namedCurve: `NODE-${namedCurve}`\n        };\n        keyUsages = isPublic ? ['verify'] : ['sign'];\n        break;\n\n      default:\n        throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n  });\n\n  return function genericImport(_x4, _x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport const fromPKCS8 = (pem, alg, options) => {\n  return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n  return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/runtime/asn1.js"],"names":["isCloudflareWorkers","isNodeJs","crypto","isCryptoKey","invalidKeyInput","encodeBase64","formatPEM","JOSENotSupported","types","genericExport","keyType","keyFormat","key","TypeError","extractable","type","Uint8Array","subtle","exportKey","toUpperCase","toSPKI","toPKCS8","findOid","keyData","oid","from","unshift","length","i","indexOf","sub","subarray","every","value","index","getNamedCurve","genericImport","replace","pem","alg","options","_a","algorithm","keyUsages","atob","split","map","c","charCodeAt","isPublic","name","hash","slice","parseInt","namedCurve","importKey","fromPKCS8","fromSPKI"],"mappings":"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","sourcesContent":["import { isCloudflareWorkers, isNodeJs } from './env.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst findOid = (keyData, oid, from = 0) => {\n    if (from === 0) {\n        oid.unshift(oid.length);\n        oid.unshift(0x06);\n    }\n    let i = keyData.indexOf(oid[0], from);\n    if (i === -1)\n        return false;\n    const sub = keyData.subarray(i, i + oid.length);\n    if (sub.length !== oid.length)\n        return false;\n    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\nconst getNamedCurve = (keyData) => {\n    switch (true) {\n        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n            return 'P-256';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n            return 'P-384';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n            return 'P-521';\n        case (isCloudflareWorkers() || isNodeJs()) && findOid(keyData, [0x2b, 0x65, 0x70]):\n            return 'Ed25519';\n        case isNodeJs() && findOid(keyData, [0x2b, 0x65, 0x71]):\n            return 'Ed448';\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n    }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n    var _a;\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW':\n            algorithm = { name: 'ECDH', namedCurve: getNamedCurve(keyData) };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        case (isCloudflareWorkers() || isNodeJs()) && 'EdDSA':\n            const namedCurve = getNamedCurve(keyData).toUpperCase();\n            algorithm = { name: `NODE-${namedCurve}`, namedCurve: `NODE-${namedCurve}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\n"]},"metadata":{},"sourceType":"module"}