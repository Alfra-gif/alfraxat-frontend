{"ast":null,"code":"import _asyncToGenerator from \"/home/ramon/Desktop/Institut Lacet\\xE0nia/S\\xEDntesi/Projecte/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\n\nclass IndividualSignature {\n  constructor(sig, key, options) {\n    this.parent = sig;\n    this.key = key;\n    this.options = options;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    if (this.protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this.protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this.unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this.unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  addSignature(...args) {\n    return this.parent.addSignature(...args);\n  }\n\n  sign(...args) {\n    return this.parent.sign(...args);\n  }\n\n  done() {\n    return this.parent;\n  }\n\n}\n\nexport class GeneralSign {\n  constructor(payload) {\n    this._signatures = [];\n    this._payload = payload;\n  }\n\n  addSignature(key, options) {\n    const signature = new IndividualSignature(this, key, options);\n\n    this._signatures.push(signature);\n\n    return signature;\n  }\n\n  sign() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this._signatures.length) {\n        throw new JWSInvalid('at least one signature must be added');\n      }\n\n      const jws = {\n        signatures: [],\n        payload: ''\n      };\n\n      for (let i = 0; i < _this._signatures.length; i++) {\n        const signature = _this._signatures[i];\n        const flattened = new FlattenedSign(_this._payload);\n        flattened.setProtectedHeader(signature.protectedHeader);\n        flattened.setUnprotectedHeader(signature.unprotectedHeader);\n        const {\n          payload,\n          ...rest\n        } = yield flattened.sign(signature.key, signature.options);\n\n        if (i === 0) {\n          jws.payload = payload;\n        } else if (jws.payload !== payload) {\n          throw new JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');\n        }\n\n        jws.signatures.push(rest);\n      }\n\n      return jws;\n    })();\n  }\n\n}","map":{"version":3,"sources":["/home/ramon/Desktop/Institut Lacetània/Síntesi/Projecte/node_modules/jose/dist/browser/jws/general/sign.js"],"names":["FlattenedSign","JWSInvalid","IndividualSignature","constructor","sig","key","options","parent","setProtectedHeader","protectedHeader","TypeError","setUnprotectedHeader","unprotectedHeader","addSignature","args","sign","done","GeneralSign","payload","_signatures","_payload","signature","push","length","jws","signatures","i","flattened","rest"],"mappings":"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","sourcesContent":["import { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\nclass IndividualSignature {\n    constructor(sig, key, options) {\n        this.parent = sig;\n        this.key = key;\n        this.options = options;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addSignature(...args) {\n        return this.parent.addSignature(...args);\n    }\n    sign(...args) {\n        return this.parent.sign(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature(this, key, options);\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        for (let i = 0; i < this._signatures.length; i++) {\n            const signature = this._signatures[i];\n            const flattened = new FlattenedSign(this._payload);\n            flattened.setProtectedHeader(signature.protectedHeader);\n            flattened.setUnprotectedHeader(signature.unprotectedHeader);\n            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);\n            if (i === 0) {\n                jws.payload = payload;\n            }\n            else if (jws.payload !== payload) {\n                throw new JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');\n            }\n            jws.signatures.push(rest);\n        }\n        return jws;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}